---
title: "GeoPAT 2"
subtitle: "analysis of spatial and temporal patterns"
author: "Jakub Nowosad"
date: "2018-08-22 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
          css: ["my_theme.css", "default"]
          lib_dir: libs
          nature:
                  highlightStyle: github
                  highlightLines: true
                  countIncrementalSlides: false
                  ratio: 16:9
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

layout: false
class: middle, center

# Introduction

---
layout: false
class: middle, center

# Core ideas

---
### Motifel

- Most of the spatial raster analyses use single pixels as its main unit of analysis. <!--Each pixel has one value (e.g. land cover class) and relatively small size (e.g. 90 meters).--> The value of a single pixel can show a local property, however, it says nothing about a local spatial pattern.

- <!--Therefore, the question is how a local pattern can be depicted?--> In our approach, we consider a square block of pixels as a representation of a local pattern (“motif”). This block of pixels is called a motifel and it is an elementary unit of the pattern-based spatial analysis.

<!-- - In the figure below, you can see a land cover map divided into a set of motifels. Each motifel consists of a large number of pixels and depicts a local pattern.-->

```{r, echo=FALSE, fig.cap="An example of a grid divided into motifels", out.width=800, fig.align='center'}
knitr::include_graphics("figs/01_motifel_grid.png")
```

---
### Motifel

It is worth to mention that a simple rule to decide on a size of a motifel doesn’t exist. The decision depends on the input data (e.g. its resolution, number of classes), type of a pattern, its variability, etc. However, a rule of thumb is to look closely at your data and keep in mind two things:

1. There should be enough pixels to create a pattern. That is why GeoPAT 2 does not allow for a mofitels smaller than 10 by 10 pixels.
2. Single motifels usually should not encapsulate many different patterns.

---
### Signature

.left-column2[
- **Motifel** is a spatial data representation preferable by humans as our pattern processing capabilities were improved in millions of years of evolution.
However, computers cannot see patterns in the same way as we do, and we need to transform the spatial pattern data into a form recognizable by machines.
Fortunately, there are many ways to do so and GeoPAT 2 offers some of them.
They are called **signatures**.
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/02_signatures_examples0.png")
```
]

---
### Signature

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/02_signatures_examples.png")
```

- The simplest **signature** of a motifel is its composition (Cartesian product, `prod`) - a number of cells of each map category.
It is a very compact representation, although it doesn't contain information related to the configuration of categories. 
This is a role for the following **signature** - spatial co-occurrence of categories (`cooc`).
Spatial co-occurrence of categories is a $k$ by $k$ square matrix, where $k$ is a number of classes in a landscape.
Class co-occurrence matrix counts a number of pairs of classes assigned to neighboring cells.
Next, the co-occurrence matrix is transformed into a normalized co-occurrence histogram.
In this **signature**, a landscape with $k$ classes can be represented by the co-occurrence histogram of $(k^2 + k)/2$ elements.
Importantly, a $k$ number of them is related to the class composition and $(k^2 - k)/2$ is related to the class configuration.

---
### Signature

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/02_signatures_examples.png")
```

<!--Take a look at the example above and compare information depicted by the compositional and co-occurrence histograms.
The first one shows that each land cover category occupies a very similar proportion of the area.
The second one provides more information - it counts how often different categories are adjacent to each other.
These histograms also have some important properties - rotated or mirrored version of a landscape will still have the same non-spatial representation.-->

The **signatures** mentioned above are suitable for a numeric comparison between **motifels** using **similarity metrics** (more about them below).
There are three additionals **signatures** - "landscape indices" (`lind`), "selected landscape indices" (`linds`), and "Shannon entropy" (`ent`), and their role is mostly limited to describing motifels.

---
### Similarity metric

.left-column2[
- Two of the **signatures** mentioned above, `prod` and `cooc`, have a special power - they allow for comparisons between any pair of motifels. 
In a similar way, as a human can look at two images and decide if they are similar or not, GeoPAT 2 can take two motifels and compare their **signatures**. 
It also has important advantages comparing to a human perception. 
Firstly, the GeoPAT 2 results are consistent and reproducible, while human perception can be erratic and differs between individuals.
Secondly, GeoPAT 2 gives a numerical value of similarity between two motifels.
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/03_motifel_signatures.png")
```
]

---
### Similarity metric

.left-column2[
- To calculate a similarity between them we need to have a way to measure how these histograms are alike. 
GeoPAT 2 has several **similarity metrics** that were build to compare two histograms.
<!--This numerical value depends on a selected similarity metric.-->
It includes Jensen Shannon divergence (`jsd`), Triangular (`tri`),  Wave-Hedges distance (`wh`), and Jaccard distance (`jac`).
They are explained in detail in [the GeoPAT 2 manual](https://zenodo.org/record/1291123).
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/03_motifel_signatures.png")
```
]

---
### Similarity metric

.left-column2[
```{r, echo=FALSE, warning=FALSE}
jsd_result = structure(list(V1 = c(0, 0.114750416014047, 0.00293772511887314),
                            V2 = c(0.114750416014047, 0, 0.089399714585066),
                            V3 = c(0.00293772511887314, 0.089399714585066, 0)), 
                       row.names = c(NA, -3L), class = c("tbl_df", "tbl", "data.frame"))
knitr::kable(jsd_result, 
             digits = 3,
             row.names = c(1, 2, 3),
             col.names = c(1, 2, 3),
             caption = "Comparision of the Jensen Shannon divergence values between the example motifels (landscapes)", format = "html")
```

- I've calculated the Jensen Shannon divergence values between the three examples from the above figure.
The smaller this value is the more similar are two **motifels**.
The results are, as expected, consistent with the human perception. 
The first and third motifel are the most similar with the `jsd` value of 0.003 - both motifels have only three categories and their patterns are analogous.
The second motifel is less similar to both the first one (the `jsd` value of 0.115) and the third one (the `jsd` value of 0.089). 
It has an additional land cover category ("grassland"), different proportions of land cover categories and their configurations.
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/03_motifel_signatures.png")
```
]

---
layout: false
class: middle, center

# Installation

---
layout: false
class: middle, center

# Datasets


---
layout: false
class: middle, center

# Search

---
### Search

- Nowadays, convenient search engines (such as [Google](https://www.google.com/) or [DuckDuckGo](https://duckduckgo.com/)) are essential tools in everyday life. 
We check the news, look for the products reviews, or find the way [how to make solar eclipse glasses](https://trends.google.com/trends/yis/2017/GLOBAL/).
Most of our searches have one thing in common though - they are based on text phrases.
Additionally, some less common search methods are possible, including [reverse image search](https://support.google.com/websearch/answer/1325808).

- Spatial data analysis also offers several distinct ways to search. 
Some only depends on [values in a vector's attribute table](http://geocompr.robinlovelace.net/attr.html#vector-attribute-subsetting) or [raster's values](http://geocompr.robinlovelace.net/attr.html#raster-subsetting). 
There are also methods that search based on spatial properties of the data, for example, how [an object relate in space to another one](http://geocompr.robinlovelace.net/spatial-operations.html#spatial-subsetting).
You can look for intersections, touches, is within, etc.
Finally, it is possible to search by distance.

---
### Search

Can you guess what are we missing in this long list?
Yes, you're (probably) right!
Finding places with similar spatial patterns is not a standard spatial operation.
However, it could be useful to solve many potential questions.
For example, you observed some ecological process and assume that it depends on a pattern of land cover.
Next, you need to find and study areas of similar land cover patterns to validate your results.
Fortunately, finding similar spatial patterns is one of the GeoPAT 2 main features.

It consists of three steps:

1. Extracting local pattern features of a query (location of interest).
2. Creating a grid of motifels.
3. Comparing a query and a grid of motifels.

---
### Search

- Spatial pattern search requires just two things - a query (location of interest) and a context (the same data of a larger area).
In this example, we use a 6 by 6 km site in Pilliga Forests in New South Wales, Australia as our location of interest.

- This area is mostly occupied by evergreen and deciduous broad-leaved forest, but also has a few smaller patches of shrublands.

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/search01.png")
```
]

---
### Search - step 1

- In the first step, we need to convert this map (spatial patterns of categories) into a numerical **signature** (read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **signatures**) using the `gpat_pointshis` module.
It requires a number of parameters:

- `-i` - an input map covering the whole area that we want to be searched
- `-o` - a name of the output text file containing **a signature** of the query
- `-s` - a representation of the query (a type of **signature**)
- `-x` and `-y` - x and y coordinates of the query (alternatively, a file with coordinates can be provided with `--xy_file=<file_name>`)
- `-z` - a size of the query in pixels

```{bash, eval = FALSE}
gpat_pointshis -i cci_lc2015.tif -o query_signature.txt -s cooc -x 1457570 -y -3562186 -z 20
```

- In this example, a land cover dataset with a resolution of 300 meters and covering Australia is our input map.
We selected the spatial co-occurrence of categories (`cooc`) as a type of **signature** because we are interested not only in a composition of land cover classes but also in its pattern.
The last parameters determine coordinates of a central point (`-x 1457570 -y -3562186`) and the size of a query (`-z 20`). 
In other words, the area of interest is a rectangle of 6000 by 6000 meters (20 pixels x map resolution of 300 meters) with the above coordinates in the middle.

---
### Search - step 2

.left-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/australia_ccilc.png")
```
]

.right-column2[
In the second step, we create a grid of motifels - a database of patterns for the area of Australia.

Using the `gpat_gridhis` module, we need to provide:

- `-i` - an input map covering the whole area that we want to be searched
- `-o` - a name of the output file containing signatures of each landscape in the input map (a grid of motifels)
- `-s` - a representation of the query (a type of **signature**)
- `-z` and `-f` - a size of the landscapes from which signatures will be extracted

```{bash, eval = FALSE}
gpat_gridhis -i cci_lc2015.tif -o reference.grd -s cooc -z 20 -f 20
```
]

---
### Search - step 3

- Finally, we compare pattern in our query (step 1) with every local 6 by 6 km patterns on the whole continent (step 2).
Therefore, only four parameters are required by `gpat_search`:

- `-i` - a grid of motifels
- `-o` - a final map of similarity between `-i` and `-r`
- `-r` - a text file with a numerical **signature** of our query
- `-m` - a selected [**similarity metric**](read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **similarity metrics**)

```{bash, eval = FALSE}
gpat_search -i reference.grd -o similarity_output -r query_signature.txt -m jsd
```

---
### Search

.left-column2[
- The output map is a raster of similarity between our query and the reference map.

- Most of the reference map's area is very different than our query (low values of similarity indicated by dark colors).
However, there is also a visible number of places with a very similar local pattern. 
They are located in the south-west and east Australia and on Tasmania.
]

.right-column2[
```{r, echo=FALSE, fig.cap="Similarity of land cover patterns between the query and the reference map", out.width=500, fig.align='center'}
knitr::include_graphics("figs/search03.png")
```
]

---
### Search

- Finally, we can just use standard GIS methods and extract areas with the most similar land cover pattern to our query.

- They do not only have the same land cover classes, but also its composition and configuration are very similar.

```{r, echo=FALSE, fig.cap="The query and six the most similar local landscapes to it", out.width=500, fig.align='center'}
knitr::include_graphics("figs/search04.png")
```

---
### Search

```{bash, eval=FALSE}
gpat_pointshis -i cci_lc2015.tif -o query_signature.txt -s cooc -x 1457570 -y -3562186 -z 20
gpat_gridhis -i cci_lc2015.tif -o reference.grd -s cooc -z 20 -f 20
gpat_search -i reference.grd -o similarity_output -r query_signature.txt -m jsd
```

---
### Search - resources

<!--webapp-->

---
### Search - resources

<!--papers??-->

---
layout: false
class: middle, center

# Compare

---
### Compare

Imagine you have two values expressing the world population in 1950 (2.5 billion people) and 2012 (7.1 billion people).
How would you compare the change in the world population?
The easiest (and correct) approach is just to subtract the past value from the more recent one:

$$
7.1 - 2.5 = 4.6
$$

We can conclude that the world population between 1950 and 2015 increased by 4.6 billion people.

Now, let's move into a more spatial problem.
Think about how you can compare two satellite images or raster maps.
Usually, the process is the same as in the example above - values in the image B are subtracted by values in the corresponding cells in the image A. 
This can be used to determine how land cover changes.
Two raster land cover maps are just analyzed pixel by pixel, e.g. this pixel did change from forest to agriculture and that pixel did not change as it is classified as forest on both maps.
It a good approach when we are interested in, e.g. overall changes over an extended area.
This way you can say, for example, that globally in the last 25 year we lost this area of forest, but gain this area of agriculture.

---
### Compare

.pull-left[
However, while this approach is helpful in many cases, it cannot solve all of the problems. 
Let’s consider these two areas, the left one represents an earlier time A and the right one represents a later time B.

```{r, echo=FALSE, fig.cap="Example landscape in two times A and B", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare01a.png")
```
]

.pull-right[
When we compare it using the standard method (pixel by pixel) we get the result below:

```{r, echo=FALSE, fig.cap="Pixel by pixel change in the example landscape between time A and time B", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare01b.png")
```

The changes analyzed this way are very prominent - about a half of the area had changed the category.
However, when you look back at the whole landscape in time A and B, you should notice that both images are very similar if one disregards details and orientations. 
They both have the same number of categories, their share in the landscape is comparable and they are arranged in a similar spatial pattern.
While we can say that many pixels have changed their values, we cannot say that this landscape’s pattern changed a lot. 
]

---
### Compare

Therefore, to be able to fully describe the change of a landscape, we need to be able not only to see the changes in single pixels but also changes in spatial patterns.

Pixel by pixel analyses are a part of standard raster calculators, but comparing spatial patterns is a role for GeoPAT 2. 
This consists of two steps:

1. Creating a grid of motifels.
2. Comparing a query and a grid of motifels.

---
### Compare - step 1

```{bash, eval = FALSE}
gpat_gridhis -i cci_lc2000.tif -o patterns2000.grd -z 50 -f 50 -s cooc 
gpat_gridhis -i cci_lc2015.tif -o patterns2015.grd -z 50 -f 50 -s cooc 
```

These grids, `patterns2000.grd` and `patterns2015.grd`, contain a large number of [motifels](/post/pattern-based-spatial-analysis-core-ideas/#motiel) that are represented by [signatures](/post/pattern-based-spatial-analysis-core-ideas/#signature).
In the code above, we specify the input (`-i`) and the outputs (`-o`) files, while other parameters control a size of motifels and a signature used.
Here, each motifel is a rectangle of 15,000 by 15,000 meters (`-z 50`: 50 pixels x map resolution of 300 meters).
Importantly, motifels should not overlap, therefore we shift the subsequent motifels by 15,000 meters (`-f 50`: 50 pixels x map resolution of 300 meters).
The last argument, `-s`, is crucial here. 
We can use `-s prod` that only represents shares of land cover categories or `-s cooc`, a spatial co-occurrence, that represents a spatial pattern.

---
### Compare - step 2

The second and final step is to use the outputs of the first step and compare their signatures.
Three parameters are required here:

- `-i` - this parameter is used twice, for the first and the second input grid (results of the first step)
- `-o` - a name of the output GeoTIFF file
- `-m` - selected [**similarity metric**](read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **similarity metrics**)

```{bash, eval = FALSE}
gpat_compare -i patterns2000.grd -i patterns2015.grd -o similarity0015.tif -m jsd
```

---
### Compare

The result is a raster map of similarities between Australia's land cover in 2000 and 2015.
Each pixel in this raster has a resolution of 15,000 meters and a value between 0 and 1.
The largest value, 1, means that the spatial pattern in these two years is identical (no change in pattern has occured), while lower values represent areas with more and more dissimilar patterns (increasing degree of change in pattern has occured).

```{r, echo=FALSE, fig.cap="Similarity of land cover patterns (a magnitude of pattern change) between the years 2000 and 2015", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare03.png")
```

Large areas in northern and south-eastern Australia showed no change or very small change of spatial patterns of land cover (values of similarity close to 1). 
At the same time, there are a visible number of changed landscapes and their spatial distribution is not random. 
Now, they can be analyzed in more detail - we can look at what kind of landscapes changed the most (e.g. mosaic of forest and grassland), what is a trend in patterns changes (replacing grasslands with croplands), or what is the degree of spatial pattern changes.

---
### Compare

Just to give you an example, below are six pairs of landscapes of different levels of similarity:

The most extreme example in top right corner represents an almost complete change from a bare area into a sparse vegetation.
The next ones show decreasing levels of change, with the fifth example where just a small percentage of the area actually had changed.
Finally, the last example has a similarity of 1, which means that its spatial pattern did not change. 

```{r, echo=FALSE, fig.cap="Six examples of pairs of motifels with different levels of similarity", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare04.png")
```

---
### Compare - resources

---
### Compare - resources

---
layout: false
class: middle, center

# Segmentation

---
### Segmentation

- Spatial patterns are an underexplored venue of the Earth and ecological sciences. They could be both an effect of some processes and at the same time affect other ones. For example, a land cover pattern (spatial arrangement of land cover categories) could exist because of an impact of a terrain topology, soils, climate, or human action. Next, this pattern can influence abiotic (e.g. some land cover patterns can be better to prevent erosion and flood than others) and biotic (e.g. some land cover patterns creates habitats for certain animals) components.

- Although patterns are sometimes easy to see on a map, their delineation is difficult. Probably the most crucial obstacle is the undefinability of patterns’ borders. There is not a ground truth that enables you to validate which areas have a homogenous pattern and where the line between two patterns should be drawn. Moreover, several practical problems exist - manual delineation of patterns is inconsistent, very often bias and hardly reproducible as different people have different definitions of patterns in their minds. On top of that there is an issue of time - how long would it take to create a detailed pattern-based regionalization on a global scale?

---
### Segmentation

GeoPAT 2 provides a fast, consistent, but also a highly customizable way to regionalize space based on the underlining spatial patterns.
It also has methods to analyze the quality of the output regionalization.
The pattern-based segmentation process consists of three steps:

1. Creating a grid of motifels.
2. Regionalizing of homogeneous patterns.
3. Obtaining quality of the segmentation.

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation00.png")
```

---
### Segmentation - step 1

In the first step, we need to create a grid of motifels.

```{bash, eval = FALSE}
gpat_gridhis -i cci_lc2015.tif -o patterns2015.grd -z 25 -f 25 -s cooc 
```

The `patterns2015.grd` grid contains a large number of [motifels](/post/pattern-based-spatial-analysis-core-ideas/#motiel) that are represented by the spatial coocurrence of categories.
Motifels are rectangles of 7,500 by 7,500 meters (`-z 25`: 25 pixels x map resolution of 300 meters) covering the whole area of Australia. 
However, you need to keep in mind that they are going to be converted into "brick" blocks of 15,000 by 15,000 meters in the segmentation step.
More about the "brick" topology in a moment...

---
### Segmentation - step 2

The second step is to create regions of homogeneous patterns using the output of the first step.
Segmentation result depends on several parameters:

- `-i` - an input grid of motifels (output from the first step)
- `-o` - a name of the output GeoTIFF file - the result in a raster format
- `-v` - a name of the output GeoPackage file - the result in a vector format
- `-m` - selected [**similarity metric**](read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **similarity metrics**)
- `--lthreshold` - minimum distance threshold to build areas (see the examples below). It controls segments' sizes
- `--uthreshold` - maximum distance threshold to build areas (see the examples below). It prevents the growth of
inhomogeneous segments
- `--swap` - improve segmentation by swapping unmatched areas. 0 forces repetition until all unmatched segments will be swapped, while 1 skip this process
- `--minarea` - suppress creation of segments smaller than the set value
- `--maxhist` - decide how many neighbors are used to calculate similarity. When 0 is set it uses all of the neighbors, which can be time-consuming
- `-q` - set the root topology instead of the brick topology (see the examples below)
- `-t` - segmentation can be a computationally demanding process. This option allows using multiple CPU threads

Additional parameters are either experimental (`--weights`) or are used mostly for diagnostics purposes (`-g`, `-r`).
Before digging deep into the parameters, let's try and leave the default values of most of them:

```{bash, eval = FALSE}
# example A
gpat_segment -i patterns2015.grd -o segments2015.tif -v segments2015.gpkg -m jsd -t 3
```

---
### Segmentation - step 2

Using only three CPU threads, this process should take about four minutes on a modern laptop for the whole area of Australia.
The result of the pattern-based segmentation consists of a large number of regions of varied size.
Some of them are relatively small (one motifel) - they are different from the surrounding, while others span over large areas.
To make it easier to see how segmentation works, let's focus on the area in north-eastern Australia defined by the red rectangle:

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation01.png")
```

---
### Segmentation - step 2

ne of the most important concepts here is the way how motifels are created.
Segmentation differs in this element from the rest of the spatial pattern-based analysis, as it uses so-called "brick topology".
Before the segmentation process can even start, grid created in the first step is transformed into a set "bricks" consisting of four motifels that are laid in alternate layers (see the figure below).
Therefore, when you set the size to 25 in the first step, the segmented motifels would have a size of 50 by 50 cells (four motifels of 25 by 25).
The "brick" topology allows creating segments using 6-connectivity, which gives better results than a simple 4-connectivity.

```{r, echo=FALSE, fig.cap="Segmentation output on the top of a land cover map for an area in north-eastern Australia", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation02a.png")
```

---
### Segmentation - step 2

Segmentation process consists of several steps that are explained in the ["Multi-scale segmentation algorithm for pattern-based partitioning of large categorical rasters"](https://eartharxiv.org/smva7/) article.
However, the most basic part to understand is how the segment growing works.
We start from one motifel and calculate its similarity with all of the adjacent motifels.
Next, we merge it with the most similar one and this process is repeated until we get to the threshold value:

```{r, echo=FALSE, fig.cap="Illustration of the segment growing process", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation03.png")
```

---
### Segmentation - step 3

As I have mentioned in the introduction, ground truth does not exist in the pattern-based regionalization. 
However, we can measure several properties of the output segments and they could give us an insight into how good our results are.
All of them have values between 0 and 1.
The most important first-order property is inhomogeneity, which tells how internally inconsistent each segment is.
Our main goal of segmentation is to obtain regions of homogeneous patterns, therefore we want this value to be as low as possible. 

```{r, echo=FALSE, fig.cap="Inhomogeneity of the example segmentation", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation04a.png")
```

---
### Segmentation - step 3

Secondary property of segmentation is isolation - we want regions that are distinct from their surroundings and therefore we aim for high values of isolation.
However, you need to keep in mind that inhomogeneity and isolation are not equally important. 
You may want to obtain regions of homogeneous patterns that are not drastically isolated from surroundings, however isolated yet inhomogenous regions are usually meaningless.

```{r, echo=FALSE, fig.cap="Isolation of the example segmentation", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation04b.png")
```

---
### Segmentation - step 3

Finally, segmentation quality can be calculated as:

$$1 - (inhomogeneity/isolation)$$

It gives an overall metric of the output, where the larger the value the better.

```{r, echo=FALSE, fig.cap="Quality of the example segmentation", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation04c.png")
```

---
### Segmentation control

Pattern-based segmentation is a complex operation and visibly depends on several parameters mentioned above.
Let's try to manipulate some of them and see the results:

```{bash, eval = FALSE}
# example B
gpat_segment -i patterns2015.grd -o segments2015_B.tif -v segments2015_B.gpkg -m jsd -t 3 --lthreshold=0.3 --uthreshold=0.5
# example C
gpat_segment -i patterns2015.grd -o segments2015_C.tif -v segments2015_C.gpkg -m jsd -t 3 --minarea=6
# example D
gpat_segment -i patterns2015.grd -o segments2015_D.tif -v segments2015_D.gpkg -m jac -t 3
# example E
gpat_gridhis -i cci_lc2015.tif -o patterns2015_100.grd -s cooc -z 100 -f 100
gpat_segment -i patterns2015_100.grd -o segments2015_E.tif -v segments2015_E.gpkg -m jsd -t 3 -q
```

---
### Segmentation control

```{r, echo=FALSE, fig.cap="Five examples of segmentation with a different set of parameters", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation05.png")
```

Example A uses the default values of the segmentation.
In the second example (B), we increased values of two parameters, `--lthreshold` and `--uthreshold`.
The first controls how homogenous the output regions should be in terms of patterns, with larger values indicating more inhomogenous regions (which also means larger regions/smaller number of segments).
The second one prevents the growth of too large inhomogeneous segments.
Example C has the `--minarea` parameter set to 6, which suppress creation of segments with fewer motifels than the set number.
In example D, we used Jaccard distance, a different similarity measure. 
It gave fairly similar results to the Janson-Shannon divergence but different in details.
And finally, example E used a root topology (also know as 4-connectivity). 
In the growing stage, it can only use neighbors from the left, right, top, and bottom.
As a result, the output segmentation seems more clunky and the segments are aligned along horizontal and vertical lines.

---
### Segmentation - resources

---
### Segmentation - resources

---
layout: false
class: middle, center

# Clustering

---
layout: false
class: middle, center

# Extendibility

---
layout: false
class: middle, center

# Conclusions

---
layout: false
class: inverse, middle, center

```{r, include=FALSE, eval=FALSE}
devtools::install_github("ropenscilabs/icon")
```

## Thank you

.pull-left[
## Me:

Twitter: `r icon::ii_social_twitter()` jakub_nowosad

Email: nowosad.jakub@gmail.com
]

.pull-right[
## Resources:

https://nowosad.github.io

http://sil.uc.edu
]

.footnote[
**Slides:** https://github.com/Nowosad/geostat18
]

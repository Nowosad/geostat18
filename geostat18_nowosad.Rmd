---
title: "GeoPAT 2"
subtitle: "analysis of spatial and temporal patterns"
author: "Jakub Nowosad"
date: "2018-08-22 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
          css: ["my_theme.css", "default"]
          lib_dir: libs
          nature:
                  highlightStyle: github
                  highlightLines: true
                  countIncrementalSlides: false
                  ratio: 16:9
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

layout: false
class: middle, center

# Introduction

---
### Introduction


---
### Introduction


---
### Introduction

---
layout: false
class: middle, center

# Core ideas

---
### Motifel

- Most of the spatial raster analyses use single pixels as its main unit of analysis. <!--Each pixel has one value (e.g. land cover class) and relatively small size (e.g. 90 meters).--> The value of a single pixel can show a local property, however, it says nothing about a local spatial pattern.

- <!--Therefore, the question is how a local pattern can be depicted?--> In our approach, we consider a square block of pixels as a representation of a local pattern (“motif”). This block of pixels is called a motifel and it is an elementary unit of the pattern-based spatial analysis.

<!-- - In the figure below, you can see a land cover map divided into a set of motifels. Each motifel consists of a large number of pixels and depicts a local pattern.-->

```{r, echo=FALSE, fig.cap="An example of a grid divided into motifels", out.width=800, fig.align='center'}
knitr::include_graphics("figs/01_motifel_grid.png")
```

---
### Motifel

It is worth to mention that a simple rule to decide on a size of a motifel doesn’t exist. The decision depends on the input data (e.g. its resolution, number of classes), type of a pattern, its variability, etc. However, a rule of thumb is to look closely at your data and keep in mind two things:

1. There should be enough pixels to create a pattern. That is why GeoPAT 2 does not allow for a mofitels smaller than 10 by 10 pixels.
2. Single motifels usually should not encapsulate many different patterns.

---
### Signature

.left-column2[
- **Motifel** is a spatial data representation preferable by humans as our pattern processing capabilities were improved in millions of years of evolution.
However, computers cannot see patterns in the same way as we do, and we need to transform the spatial pattern data into a form recognizable by machines.
Fortunately, there are many ways to do so and GeoPAT 2 offers some of them.
They are called **signatures**.
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/02_signatures_examples0.png")
```
]

---
### Signature

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/02_signatures_examples.png")
```

- The simplest **signature** of a motifel is its composition (Cartesian product, `prod`) - a number of cells of each map category.
It is a very compact representation, although it doesn't contain information related to the configuration of categories. 
This is a role for the following **signature** - spatial co-occurrence of categories (`cooc`).
Spatial co-occurrence of categories is a $k$ by $k$ square matrix, where $k$ is a number of classes in a landscape.
Class co-occurrence matrix counts a number of pairs of classes assigned to neighboring cells.
Next, the co-occurrence matrix is transformed into a normalized co-occurrence histogram.
In this **signature**, a landscape with $k$ classes can be represented by the co-occurrence histogram of $(k^2 + k)/2$ elements.
Importantly, a $k$ number of them is related to the class composition and $(k^2 - k)/2$ is related to the class configuration.

---
### Signature

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/02_signatures_examples.png")
```

<!--Take a look at the example above and compare information depicted by the compositional and co-occurrence histograms.
The first one shows that each land cover category occupies a very similar proportion of the area.
The second one provides more information - it counts how often different categories are adjacent to each other.
These histograms also have some important properties - rotated or mirrored version of a landscape will still have the same non-spatial representation.-->

The **signatures** mentioned above are suitable for a numeric comparison between **motifels** using **similarity metrics** (more about them below).
There are three additionals **signatures** - "landscape indices" (`lind`), "selected landscape indices" (`linds`), and "Shannon entropy" (`ent`), and their role is mostly limited to describing motifels.

---
### Similarity metric

.left-column2[
- Two of the **signatures** mentioned above, `prod` and `cooc`, have a special power - they allow for comparisons between any pair of motifels. 
In a similar way, as a human can look at two images and decide if they are similar or not, GeoPAT 2 can take two motifels and compare their **signatures**. 
It also has important advantages comparing to a human perception. 
Firstly, the GeoPAT 2 results are consistent and reproducible, while human perception can be erratic and differs between individuals.
Secondly, GeoPAT 2 gives a numerical value of similarity between two motifels.
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/03_motifel_signatures.png")
```
]

---
### Similarity metric

.left-column2[
- To calculate a similarity between them we need to have a way to measure how these histograms are alike. 
GeoPAT 2 has several **similarity metrics** that were build to compare two histograms.
<!--This numerical value depends on a selected similarity metric.-->
It includes Jensen Shannon divergence (`jsd`), Triangular (`tri`),  Wave-Hedges distance (`wh`), and Jaccard distance (`jac`).
They are explained in detail in [the GeoPAT 2 manual](https://zenodo.org/record/1291123).
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/03_motifel_signatures.png")
```
]

---
### Similarity metric

.left-column2[
```{r, echo=FALSE, warning=FALSE}
jsd_result = structure(list(V1 = c(0, 0.114750416014047, 0.00293772511887314),
                            V2 = c(0.114750416014047, 0, 0.089399714585066),
                            V3 = c(0.00293772511887314, 0.089399714585066, 0)), 
                       row.names = c(NA, -3L), class = c("tbl_df", "tbl", "data.frame"))
knitr::kable(jsd_result, 
             digits = 3,
             row.names = c(1, 2, 3),
             col.names = c(1, 2, 3),
             caption = "Comparision of the Jensen Shannon divergence values between the example motifels (landscapes)", format = "html")
```

- I've calculated the Jensen Shannon divergence values between the three examples from the above figure.
The smaller this value is the more similar are two **motifels**.
The results are, as expected, consistent with the human perception. 
The first and third motifel are the most similar with the `jsd` value of 0.003 - both motifels have only three categories and their patterns are analogous.
The second motifel is less similar to both the first one (the `jsd` value of 0.115) and the third one (the `jsd` value of 0.089). 
It has an additional land cover category ("grassland"), different proportions of land cover categories and their configurations.
]

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/03_motifel_signatures.png")
```
]

---
layout: false
class: middle, center

# Installation

---
## Installation

**Windows installer**

The Windows x64 installer is available at http://sil.uc.edu/cms/data/uploads/software_data/GPAT2/GPAT2setup.exe

**Building from source code**

To build **GeoPAT** 2 from the source code, the development files for GDAL are required.
They can be installed on Ubuntu using:

```bash
sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable --yes
sudo apt-get --yes --force-yes update -qq
sudo apt-get install --yes libgdal-dev
```
... or on Fedora with:

```bash
sudo dnf install gdal-devel
```

The source code of **GeoPAT** 2 is available at https://github.com/Nowosad/geopat2/archive/master.zip. 
This archive should be unpacked, compiled and installed:

```bash
make
sudo make install
```

---
## Installation

Some examples also use **rgeopat2** - [an R package with additional functions for GeoPAT 2](https://github.com/Nowosad/rgeopat2):

```{r, eval=FALSE}
install.packages("rgeopat2")
```

---
layout: false
class: middle, center

# Datasets

---
## Datasets

- [cci_lc2015.tif](http://sil.uc.edu/cms/data/uploads/software_data/gpat2bp/cci_lc2015.zip)
- [cci_lc2000.tif](http://sil.uc.edu/cms/data/uploads/software_data/gpat2bp/cci_lc2000.zip)
- [tnc_terr_ecoregions.tif](http://sil.uc.edu/cms/data/uploads/software_data/gpat2bp/tnc_terr_ecoregions.zip)

---
layout: false
class: middle, center

# Search

---
### Search

- Nowadays, convenient search engines (such as [Google](https://www.google.com/) or [DuckDuckGo](https://duckduckgo.com/)) are essential tools in everyday life. 
We check the news, look for the products reviews, or find the way [how to make solar eclipse glasses](https://trends.google.com/trends/yis/2017/GLOBAL/).
Most of our searches have one thing in common though - they are based on text phrases.
Additionally, some less common search methods are possible, including [reverse image search](https://support.google.com/websearch/answer/1325808).

- Spatial data analysis also offers several distinct ways to search. 
Some only depends on [values in a vector's attribute table](http://geocompr.robinlovelace.net/attr.html#vector-attribute-subsetting) or [raster's values](http://geocompr.robinlovelace.net/attr.html#raster-subsetting). 
There are also methods that search based on spatial properties of the data, for example, how [an object relate in space to another one](http://geocompr.robinlovelace.net/spatial-operations.html#spatial-subsetting).
You can look for intersections, touches, is within, etc.
Finally, it is possible to search by distance.

---
### Search

Can you guess what are we missing in this long list?
Yes, you're (probably) right!
Finding places with similar spatial patterns is not a standard spatial operation.
However, it could be useful to solve many potential questions.
For example, you observed some ecological process and assume that it depends on a pattern of land cover.
Next, you need to find and study areas of similar land cover patterns to validate your results.
Fortunately, finding similar spatial patterns is one of the GeoPAT 2 main features.

It consists of three steps:

1. Extracting local pattern features of a query (location of interest).
2. Creating a grid of motifels.
3. Comparing a query and a grid of motifels.

---
### Search

- Spatial pattern search requires just two things - a query (location of interest) and a context (the same data of a larger area).
In this example, we use a 6 by 6 km site in Pilliga Forests in New South Wales, Australia as our location of interest.

- This area is mostly occupied by evergreen and deciduous broad-leaved forest, but also has a few smaller patches of shrublands.

.right-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/search01.png")
```
]

---
### Search - step 1

- In the first step, we need to convert this map (spatial patterns of categories) into a numerical **signature** (read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **signatures**) using the `gpat_pointshis` module.
It requires a number of parameters:

- `-i` - an input map covering the whole area that we want to be searched
- `-o` - a name of the output text file containing **a signature** of the query
- `-s` - a representation of the query (a type of **signature**)
- `-x` and `-y` - x and y coordinates of the query (alternatively, a file with coordinates can be provided with `--xy_file=<file_name>`)
- `-z` - a size of the query in pixels

```{bash, eval = FALSE}
gpat_pointshis -i cci_lc2015.tif -o query_signature.txt -s cooc -x 1457570 -y -3562186 -z 20
```

- In this example, a land cover dataset with a resolution of 300 meters and covering Australia is our input map.
We selected the spatial co-occurrence of categories (`cooc`) as a type of **signature** because we are interested not only in a composition of land cover classes but also in its pattern.
The last parameters determine coordinates of a central point (`-x 1457570 -y -3562186`) and the size of a query (`-z 20`). 
In other words, the area of interest is a rectangle of 6000 by 6000 meters (20 pixels x map resolution of 300 meters) with the above coordinates in the middle.

---
### Search - step 2

.left-column2[
```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/australia_ccilc.png")
```
]

.right-column2[
In the second step, we create a grid of motifels - a database of patterns for the area of Australia.

Using the `gpat_gridhis` module, we need to provide:

- `-i` - an input map covering the whole area that we want to be searched
- `-o` - a name of the output file containing signatures of each landscape in the input map (a grid of motifels)
- `-s` - a representation of the query (a type of **signature**)
- `-z` and `-f` - a size of the landscapes from which signatures will be extracted

```{bash, eval = FALSE}
gpat_gridhis -i cci_lc2015.tif -o reference.grd -s cooc -z 20 -f 20
```
]

---
### Search - step 3

- Finally, we compare pattern in our query (step 1) with every local 6 by 6 km patterns on the whole continent (step 2).
Therefore, only four parameters are required by `gpat_search`:

- `-i` - a grid of motifels
- `-o` - a final map of similarity between `-i` and `-r`
- `-r` - a text file with a numerical **signature** of our query
- `-m` - a selected [**similarity metric**](read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **similarity metrics**)

```{bash, eval = FALSE}
gpat_search -i reference.grd -o similarity_output -r query_signature.txt -m jsd
```

---
### Search

.left-column2[
- The output map is a raster of similarity between our query and the reference map.

- Most of the reference map's area is very different than our query (low values of similarity indicated by dark colors).
However, there is also a visible number of places with a very similar local pattern. 
They are located in the south-west and east Australia and on Tasmania.
]

.right-column2[
```{r, echo=FALSE, fig.cap="Similarity of land cover patterns between the query and the reference map", out.width=500, fig.align='center'}
knitr::include_graphics("figs/search03.png")
```
]

---
### Search

- Finally, we can just use standard GIS methods and extract areas with the most similar land cover pattern to our query.

- They do not only have the same land cover classes, but also its composition and configuration are very similar.

```{r, echo=FALSE, fig.cap="The query and six the most similar local landscapes to it", out.width=500, fig.align='center'}
knitr::include_graphics("figs/search04.png")
```

---
### Search

```{bash, eval=FALSE}
gpat_pointshis -i cci_lc2015.tif -o query_signature.txt -s cooc -x 1457570 -y -3562186 -z 20
gpat_gridhis -i cci_lc2015.tif -o reference.grd -s cooc -z 20 -f 20
gpat_search -i reference.grd -o similarity_output -r query_signature.txt -m jsd
```

---
### Search - resources

.left-column2[
```{r, out.width="350px", echo=FALSE}
knitr::include_graphics("figs/search_pattern.png")
```
- **Query** - diverse landscape in the north Wisconsin (1.5 x 1.5 km)
- Mosaic of a mixed forest, evergreen forest, shrubs, woody wetlands, and water
]
.right-column2[
```{r, out.width="700px", echo=FALSE}
knitr::include_graphics("figs/search_result.png")
```
Dataset: NLCD 2011. 
Red color indicates larger similarity.
Online application available at http://sil.uc.edu/webapps/landex_usa/.
]

---
### Search - resources

<!--papers??-->

---
layout: false
class: middle, center

# Compare

---
### Compare

Imagine you have two values expressing the world population in 1950 (2.5 billion people) and 2012 (7.1 billion people).
How would you compare the change in the world population?
The easiest (and correct) approach is just to subtract the past value from the more recent one:

$$
7.1 - 2.5 = 4.6
$$

We can conclude that the world population between 1950 and 2015 increased by 4.6 billion people.

Now, let's move into a more spatial problem.
Think about how you can compare two satellite images or raster maps.
Usually, the process is the same as in the example above - values in the image B are subtracted by values in the corresponding cells in the image A. 
This can be used to determine how land cover changes.
Two raster land cover maps are just analyzed pixel by pixel, e.g. this pixel did change from forest to agriculture and that pixel did not change as it is classified as forest on both maps.
It a good approach when we are interested in, e.g. overall changes over an extended area.
This way you can say, for example, that globally in the last 25 year we lost this area of forest, but gain this area of agriculture.

---
### Compare

.pull-left[
However, while this approach is helpful in many cases, it cannot solve all of the problems. 
Let’s consider these two areas, the left one represents an earlier time A and the right one represents a later time B.

```{r, echo=FALSE, fig.cap="Example landscape in two times A and B", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare01a.png")
```
]

.pull-right[
When we compare it using the standard method (pixel by pixel) we get the result below:

```{r, echo=FALSE, fig.cap="Pixel by pixel change in the example landscape between time A and time B", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare01b.png")
```

The changes analyzed this way are very prominent - about a half of the area had changed the category.
However, when you look back at the whole landscape in time A and B, you should notice that both images are very similar if one disregards details and orientations. 
They both have the same number of categories, their share in the landscape is comparable and they are arranged in a similar spatial pattern.
While we can say that many pixels have changed their values, we cannot say that this landscape’s pattern changed a lot. 
]

---
### Compare

Therefore, to be able to fully describe the change of a landscape, we need to be able not only to see the changes in single pixels but also changes in spatial patterns.

Pixel by pixel analyses are a part of standard raster calculators, but comparing spatial patterns is a role for GeoPAT 2. 
This consists of two steps:

1. Creating a grid of motifels.
2. Comparing a query and a grid of motifels.

---
### Compare - step 1

```{bash, eval = FALSE}
gpat_gridhis -i cci_lc2000.tif -o patterns2000.grd -z 50 -f 50 -s cooc 
gpat_gridhis -i cci_lc2015.tif -o patterns2015.grd -z 50 -f 50 -s cooc 
```

These grids, `patterns2000.grd` and `patterns2015.grd`, contain a large number of [motifels](/post/pattern-based-spatial-analysis-core-ideas/#motiel) that are represented by [signatures](/post/pattern-based-spatial-analysis-core-ideas/#signature).
In the code above, we specify the input (`-i`) and the outputs (`-o`) files, while other parameters control a size of motifels and a signature used.
Here, each motifel is a rectangle of 15,000 by 15,000 meters (`-z 50`: 50 pixels x map resolution of 300 meters).
Importantly, motifels should not overlap, therefore we shift the subsequent motifels by 15,000 meters (`-f 50`: 50 pixels x map resolution of 300 meters).
The last argument, `-s`, is crucial here. 
We can use `-s prod` that only represents shares of land cover categories or `-s cooc`, a spatial co-occurrence, that represents a spatial pattern.

---
### Compare - step 2

The second and final step is to use the outputs of the first step and compare their signatures.
Three parameters are required here:

- `-i` - this parameter is used twice, for the first and the second input grid (results of the first step)
- `-o` - a name of the output GeoTIFF file
- `-m` - selected [**similarity metric**](read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **similarity metrics**)

```{bash, eval = FALSE}
gpat_compare -i patterns2000.grd -i patterns2015.grd -o similarity0015.tif -m jsd
```

---
### Compare

The result is a raster map of similarities between Australia's land cover in 2000 and 2015.
Each pixel in this raster has a resolution of 15,000 meters and a value between 0 and 1.
The largest value, 1, means that the spatial pattern in these two years is identical (no change in pattern has occured), while lower values represent areas with more and more dissimilar patterns (increasing degree of change in pattern has occured).

```{r, echo=FALSE, fig.cap="Similarity of land cover patterns (a magnitude of pattern change) between the years 2000 and 2015", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare03.png")
```

Large areas in northern and south-eastern Australia showed no change or very small change of spatial patterns of land cover (values of similarity close to 1). 
At the same time, there are a visible number of changed landscapes and their spatial distribution is not random. 
Now, they can be analyzed in more detail - we can look at what kind of landscapes changed the most (e.g. mosaic of forest and grassland), what is a trend in patterns changes (replacing grasslands with croplands), or what is the degree of spatial pattern changes.

---
### Compare

Just to give you an example, below are six pairs of landscapes of different levels of similarity:

The most extreme example in top right corner represents an almost complete change from a bare area into a sparse vegetation.
The next ones show decreasing levels of change, with the fifth example where just a small percentage of the area actually had changed.
Finally, the last example has a similarity of 1, which means that its spatial pattern did not change. 

```{r, echo=FALSE, fig.cap="Six examples of pairs of motifels with different levels of similarity", out.width=500, fig.align='center'}
knitr::include_graphics("figs/compare04.png")
```

---
### Compare - resources

```{r, out.width="850px", echo=FALSE}
knitr::include_graphics("figs/change_det.png")
```

---
### Compare - resources

<!--papers??-->

---
layout: false
class: middle, center

# Segmentation

---
### Segmentation

- Spatial patterns are an underexplored venue of the Earth and ecological sciences. They could be both an effect of some processes and at the same time affect other ones. For example, a land cover pattern (spatial arrangement of land cover categories) could exist because of an impact of a terrain topology, soils, climate, or human action. Next, this pattern can influence abiotic (e.g. some land cover patterns can be better to prevent erosion and flood than others) and biotic (e.g. some land cover patterns creates habitats for certain animals) components.

- Although patterns are sometimes easy to see on a map, their delineation is difficult. Probably the most crucial obstacle is the undefinability of patterns’ borders. There is not a ground truth that enables you to validate which areas have a homogenous pattern and where the line between two patterns should be drawn. Moreover, several practical problems exist - manual delineation of patterns is inconsistent, very often bias and hardly reproducible as different people have different definitions of patterns in their minds. On top of that there is an issue of time - how long would it take to create a detailed pattern-based regionalization on a global scale?

---
### Segmentation

GeoPAT 2 provides a fast, consistent, but also a highly customizable way to regionalize space based on the underlining spatial patterns.
It also has methods to analyze the quality of the output regionalization.
The pattern-based segmentation process consists of three steps:

1. Creating a grid of motifels.
2. Regionalizing of homogeneous patterns.
3. Obtaining quality of the segmentation.

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation00.png")
```

---
### Segmentation - step 1

In the first step, we need to create a grid of motifels.

```{bash, eval = FALSE}
gpat_gridhis -i cci_lc2015.tif -o patterns2015.grd -z 25 -f 25 -s cooc 
```

The `patterns2015.grd` grid contains a large number of [motifels](/post/pattern-based-spatial-analysis-core-ideas/#motiel) that are represented by the spatial coocurrence of categories.
Motifels are rectangles of 7,500 by 7,500 meters (`-z 25`: 25 pixels x map resolution of 300 meters) covering the whole area of Australia. 
However, you need to keep in mind that they are going to be converted into "brick" blocks of 15,000 by 15,000 meters in the segmentation step.
More about the "brick" topology in a moment...

---
### Segmentation - step 2

The second step is to create regions of homogeneous patterns using the output of the first step.
Segmentation result depends on several parameters:

- `-i` - an input grid of motifels (output from the first step)
- `-o` - a name of the output GeoTIFF file - the result in a raster format
- `-v` - a name of the output GeoPackage file - the result in a vector format
- `-m` - selected [**similarity metric**](read [the previous blog post](/post/pattern-based-spatial-analysis-core-ideas) to learn more about **similarity metrics**)
- `--lthreshold` - minimum distance threshold to build areas (see the examples below). It controls segments' sizes
- `--uthreshold` - maximum distance threshold to build areas (see the examples below). It prevents the growth of
inhomogeneous segments
- `--swap` - improve segmentation by swapping unmatched areas. 0 forces repetition until all unmatched segments will be swapped, while 1 skip this process
- `--minarea` - suppress creation of segments smaller than the set value
- `--maxhist` - decide how many neighbors are used to calculate similarity. When 0 is set it uses all of the neighbors, which can be time-consuming
- `-q` - set the root topology instead of the brick topology (see the examples below)
- `-t` - segmentation can be a computationally demanding process. This option allows using multiple CPU threads

Additional parameters are either experimental (`--weights`) or are used mostly for diagnostics purposes (`-g`, `-r`).
Before digging deep into the parameters, let's try and leave the default values of most of them:

```{bash, eval = FALSE}
# example A
gpat_segment -i patterns2015.grd -o segments2015.tif -v segments2015.gpkg -m jsd -t 3
```

---
### Segmentation - step 2

Using only three CPU threads, this process should take about four minutes on a modern laptop for the whole area of Australia.
The result of the pattern-based segmentation consists of a large number of regions of varied size.
Some of them are relatively small (one motifel) - they are different from the surrounding, while others span over large areas.
To make it easier to see how segmentation works, let's focus on the area in north-eastern Australia defined by the red rectangle:

```{r, echo=FALSE, fig.cap="LALA", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation01.png")
```

---
### Segmentation - step 2

ne of the most important concepts here is the way how motifels are created.
Segmentation differs in this element from the rest of the spatial pattern-based analysis, as it uses so-called "brick topology".
Before the segmentation process can even start, grid created in the first step is transformed into a set "bricks" consisting of four motifels that are laid in alternate layers (see the figure below).
Therefore, when you set the size to 25 in the first step, the segmented motifels would have a size of 50 by 50 cells (four motifels of 25 by 25).
The "brick" topology allows creating segments using 6-connectivity, which gives better results than a simple 4-connectivity.

```{r, echo=FALSE, fig.cap="Segmentation output on the top of a land cover map for an area in north-eastern Australia", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation02a.png")
```

---
### Segmentation - step 2

Segmentation process consists of several steps that are explained in the ["Multi-scale segmentation algorithm for pattern-based partitioning of large categorical rasters"](https://eartharxiv.org/smva7/) article.
However, the most basic part to understand is how the segment growing works.
We start from one motifel and calculate its similarity with all of the adjacent motifels.
Next, we merge it with the most similar one and this process is repeated until we get to the threshold value:

```{r, echo=FALSE, fig.cap="Illustration of the segment growing process", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation03.png")
```

---
### Segmentation - step 3

As I have mentioned in the introduction, ground truth does not exist in the pattern-based regionalization. 
However, we can measure several properties of the output segments and they could give us an insight into how good our results are.
All of them have values between 0 and 1.
The most important first-order property is inhomogeneity, which tells how internally inconsistent each segment is.
Our main goal of segmentation is to obtain regions of homogeneous patterns, therefore we want this value to be as low as possible. 

```{r, echo=FALSE, fig.cap="Inhomogeneity of the example segmentation", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation04a.png")
```

---
### Segmentation - step 3

Secondary property of segmentation is isolation - we want regions that are distinct from their surroundings and therefore we aim for high values of isolation.
However, you need to keep in mind that inhomogeneity and isolation are not equally important. 
You may want to obtain regions of homogeneous patterns that are not drastically isolated from surroundings, however isolated yet inhomogenous regions are usually meaningless.

```{r, echo=FALSE, fig.cap="Isolation of the example segmentation", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation04b.png")
```

---
### Segmentation - step 3

Finally, segmentation quality can be calculated as:

$$1 - (inhomogeneity/isolation)$$

It gives an overall metric of the output, where the larger the value the better.

```{r, echo=FALSE, fig.cap="Quality of the example segmentation", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation04c.png")
```

---
### Segmentation control

Pattern-based segmentation is a complex operation and visibly depends on several parameters mentioned above.
Let's try to manipulate some of them and see the results:

```{bash, eval = FALSE}
# example B
gpat_segment -i patterns2015.grd -o segments2015_B.tif -v segments2015_B.gpkg -m jsd -t 3 --lthreshold=0.3 --uthreshold=0.5
# example C
gpat_segment -i patterns2015.grd -o segments2015_C.tif -v segments2015_C.gpkg -m jsd -t 3 --minarea=6
# example D
gpat_segment -i patterns2015.grd -o segments2015_D.tif -v segments2015_D.gpkg -m jac -t 3
# example E
gpat_gridhis -i cci_lc2015.tif -o patterns2015_100.grd -s cooc -z 100 -f 100
gpat_segment -i patterns2015_100.grd -o segments2015_E.tif -v segments2015_E.gpkg -m jsd -t 3 -q
```

---
### Segmentation control

```{r, echo=FALSE, fig.cap="Five examples of segmentation with a different set of parameters", out.width=500, fig.align='center'}
knitr::include_graphics("figs/segmentation05.png")
```

Example A uses the default values of the segmentation.
In the second example (B), we increased values of two parameters, `--lthreshold` and `--uthreshold`.
The first controls how homogenous the output regions should be in terms of patterns, with larger values indicating more inhomogenous regions (which also means larger regions/smaller number of segments).
The second one prevents the growth of too large inhomogeneous segments.
Example C has the `--minarea` parameter set to 6, which suppress creation of segments with fewer motifels than the set number.
In example D, we used Jaccard distance, a different similarity measure. 
It gave fairly similar results to the Janson-Shannon divergence but different in details.
And finally, example E used a root topology (also know as 4-connectivity). 
In the growing stage, it can only use neighbors from the left, right, top, and bottom.
As a result, the output segmentation seems more clunky and the segments are aligned along horizontal and vertical lines.

---
### Segmentation - resources

---
### Segmentation - resources

---
layout: false
class: middle, center

# Clustering

---
### Clustering

You can also calculate similarity matrices between motifels, points, or polygons using `gpat_distmtx`. 
It accepts outputs from `gpat_grid2txt`, `gpat_pointshis`, or `gpat_polygon` and returns a CSV file containing a similarity matrix - also known as a distance matrix.
Below, we focus on the output from `gpat_grid2txt`.
Read [the GeoPAT 2 manual](https://zenodo.org/record/1291123) to see examples of clustering based on the output of `gpat_pointshis` and `gpat_polygon`.

```{bash, eval=FALSE}
gpat_distmtx -i patterns2015.txt -o similarity2015.csv
```

The output, `similarity2015.csv`, can be read into your preferable software to apply any clustering method that depends on a distance matrix.

---
### Clustering

For example, the `gpat_read_distmtx()` function can be used to read the data in R:

```{r, eval=FALSE}
dist_2015 = gpat_read_distmtx("similarity2015.csv")
```

This new object, `dist_2015`, is of the `dist` class and therefore can be used by many clustering functions, including hierarchical clustering (`hclust()`), or k-medoids clustering methods (`cluster::pam()`).

Let's try a simple example:

```{r, eval=FALSE}
hclust_result = hclust(d = dist_2015, method = "ward.D2")
plot(hclust_result, labels = FALSE)
rect.hclust(hclust_result, k = 12, border = "blue")
hclust_cut = cutree(hclust_result, 12)
my_grid$class = hclust_cut
plot(my_grid["class"])
```

---
### Clustering

We cluster motifels based on the dissimilarity matrix output of GeoPAT 2 using hierarchical clustering (function `hclust()`).
Based on the dendrogram visualization (`plot()`), we decide that the data should be divided into 12 clusters (`cutree()`):

```{r, echo=FALSE, fig.cap="Dendrogram representing hierarchical clustering", out.width=500, fig.align='center'}
knitr::include_graphics("figs/extend03a.png")
```

---
### Clustering

Finally, we add identifiers of the new clusters to our spatial object containing a grid of motifels and visualize it:

```{r, echo=FALSE, fig.cap="A map of Australia divided into twelve clusters based on the similarity of land cover composition", out.width=500, fig.align='center'}
knitr::include_graphics("figs/extend03b.png")
```


The output is a map with motifels grouped into the areas of the similar land cover composition.
Some of the clusters represent one dominant land cover category, e.g. cluster 1 is water, cluster 3 is shrubland, and cluster 7 is sparse vegetation.
On the other hand, some of the clusters can consist of many land cover categories.
For example, cluster 6 is a mosaic of grassland and sparse vegetation and cluster 8 is a mosaic of sparse vegetation and shrubland.

---
### Clustering - code

---
### Clustering - resources

---
layout: false
class: middle, center

# Extendibility

---
### Extendibility

GeoPAT 2 gives its users a lot of freedom, having a large number of possible workflows:


```{r, echo=FALSE, fig.cap="ROutline of the GeoPAT 2 architecture", out.width=500, fig.align='center'}
knitr::include_graphics("figs/gpat2.png")
```

Some of them can consist of only one step, while others require several steps.
However, that is not the end of GeoPAT 2 capabilities - it is also possible to extract spatial signature or calculate distance matrix and use these outputs in further analysis outside of GeoPAT 2.
For example, you can cluster areas of similar patterns or use machine learning methods to find numerical relationships between patterns descriptors and other variables.
Finally, there are several experimental features of GeoPAT 2, including a set of methods for analysis of spatiotemporal data.

---
### Extracting information about spatial patterns

Most of the GeoPAT 2 modules depends on spatial information about patterns in the form of [signatures](/post/pattern-based-spatial-analysis-core-ideas/#signature).
We can then [find the most similar signatures (search)](/post/geopat-2-search), [compare local signatures (comparison)](/post/geopat-2-compare), or [merge areas with similar signatures (segmentation)](/post/geopat-2-segmentation). 
This information can be also used outside of GeoPAT 2 - it is possible to fit a spatial pattern information to your own workflow.

There are three main ways to extract information about spatial patterns.
The first one extracts information from a regular grid of motifels.
In the example below, we create a grid of motifels with information about the composition of land cover categories (`-s prod`).
Next, using `gpat_grid2txt` we convert the output grid file into a text file that can be read by standard software, such as R, Python, Excel.

```{bash, eval=FALSE}
gpat_gridhis -i cci_lc2015.tif -o patterns2015.grd -s prod -z 200 -f 200
gpat_grid2txt -i patterns2015.grd -o patterns2015.txt
```

---
### Extracting information about spatial patterns

The second one extracts a spatial pattern information based on point coordinates within the given buffer.
Below, we extract a land cover composition (Cartesian product) of a square area of 30 by 30 pixels (9km by 9km) around Australia's capital - Canberra:

```{bash, eval=FALSE}
gpat_pointshis -i cci_lc2015.tif -o patterns_pts.txt -s prod -z 30 -x 1370000 -y -4050000
```

---
### Extracting information about spatial patterns

The third one involves extracting information about spatial patterns using irregular polygons with `gpat_polygon`.
Let's say, we are interested in extracting land cover composition in each of TNC's terrestrial ecoregions in Australia.
*(Due to large sizes of some ecoregions, the below calculation can require about 16GB RAM available.)*

```{bash, eval=FALSE}
gpat_polygon -i cci_lc2015.tif -e tnc_terr_ecoregions.tif -o patterns_poly.txt -s prod
```

---
### Extracting information about spatial patterns

To ease some of the non-standard GeoPAT 2 operations we created an R package called **rgeopat2**.

```{r, eval=FALSE}
library(rgeopat2)
```

Its function `gpat_read_txt()` reads the output text from GeoPAT 2 and formats it in a convinent way:

```{r, eval=FALSE}
patterns_poly = gpat_read_txt("patterns_poly.txt")
```

```{r, eval=FALSE, echo=FALSE}
knitr::kable(patterns_poly[c(1, 34), ], digits = 2, caption = "Example of two lines from the gpat_read_txt() output")
```

|   |   X1|   X2| X3|   X4|   X5|   X6|   X7|   X8|   X9| X10|  X11| X12|  X13|  X14|  X15|  X16| X17|  X18|  X19|  X20| X21|  X22|   cat|
|:--|----:|----:|--:|----:|----:|----:|----:|----:|----:|---:|----:|---:|----:|----:|----:|----:|---:|----:|----:|----:|---:|----:|-----:|
|1  | 0.00| 0.00|  0| 0.00| 0.00| 0.00| 0.00| 0.00| 0.00|   0| 0.00|   0| 0.00| 0.00| 0.00| 0.00|   0| 0.00| 0.00| 0.00|   0| 1.00|     0|
|34 | 0.00| 0.00|  0| 0.00| 0.00| 0.00| 0.00| 0.00| 0.00|   0| 0.00|   0| 0.00| 0.00| 0.54| 0.45|   0| 0.00| 0.00| 0.00|   0| 0.00| 10072|

Table: Example of two lines from the gpat_read_txt() output

The last column in this table, `cat`, represents the id of the terrestrial ecoregion, while the rest of the columns are the land cover categories.
For example, `cat` 0 is an ocean and 100% of its area is covered by water (class X22), while `cat` 10072, Gibson Desert, is located in the middle of the continent and is covered by grassland (X15) and sparse vegetation (X16).

---
### Spatiotemporal pattern-based analysis

GeoPAT 2 also offers several additional features, including spatiotemporal pattern-based analysis.
It is highly experimental, but already can be executed and tested.
Let's take a look at a couple examples from [the GeoPAT 2 manual](https://zenodo.org/record/1291123).

The input data is a set of twelve rasters of monthly sums of precipitation for the area of the British Isles from [the WorldClim database](http://www.worldclim.org/). 
Each raster has 76560 pixels (240 rows and 319 columns).
In other words, each pixel has 12 values representing temporal precipitation pattern.

```{r, echo=FALSE, fig.cap="Monthly sums of precipitation for the area of the British Isles", out.width=500, fig.align='center'}
knitr::include_graphics("figs/extend04a.png")
```

---
### Spatiotemporal pattern-based analysis

Many GeoPAT 2 methods for spatial data also work with spatiotemporal datasets.
For example, it is possible to regionalize the British Isles based on its annual precipitation patterns.
Each region has similar temporal precipitation pattern.

```{r, echo=FALSE, fig.cap="Regions of the similar annual precipitation patterns for the British Isles", out.width=500, fig.align='center'}
knitr::include_graphics("figs/extend04b.png")
```

---
### Spatiotemporal pattern-based analysis

Another GeoPAT 2 application is clustering of spatiotemporal data.
For example, we can extract temporal precipitation patterns of 97 largest cities in the British Isles and cluster them:

```{r, echo=FALSE, fig.cap="Example of a time series clustering", out.width=500, fig.align='center'}
knitr::include_graphics("figs/extend04c.png")
```

---
layout: false
class: middle, center

# Conclusions

---
### Conclustions

.pull-left[
```{r, out.width="375px", echo=FALSE}
knitr::include_graphics("figs/pattern_analysis.png")
```
Example: **Global land cover patterns** were segmented into **homogeneous areas** and their patterns were analysed with **landscape metrics**.
The results showed dependence of land cover spatial configuration on two parameters, **complexity (C)** and **aggregation (A)**. 
]

.pull-right[
- **Global environmental changes** -- analysis of changes in patterns of different environmental features, such as land cover 
- **Global ecology** - delineation of ecoregions -- regionalization of land into homogeneous units of similar ecological and physiographic features (land cover, landform, soils, climate)
- **Forestry** - regionalization of forest patterns -- results could be used for conservation, planning and management
- **Agriculture** - identification of spatial patterns of cropland usage
- **Landscape ecology** - inventory of landscape patterns and analysis of landscape spatial configuration
]

---
### Conclustions

- Pattern-based spatial analysis uses **blocks of pixels (motifels)** to represent local pattern
- This way **a large number of small simple cells are transformed into smaller number of large complex cells**
- This approach allows for **searching, detecting changes, segmentation, and clustering** of local patterns
- Main ideas behind the pattern-based spatial analysis are implemented in **GeoPAT 2.0**
- **The GeoPAT 2.0 software** and its **user’s manual** are available through the Space Informatics Lab website at http://sil.uc.edu
- GeoPAT **does not require supercomputer or cloud computing** because core calculations are performed on a grid orders of magnitude smaller than a grid of original data
- GeoPAT also allows for **temporal analysis** of large spatial datasets (see [the manual](http://doi.org/10.5281/zenodo.1185408))
- If you want to learn more about the pattern-based spatial analysis read [the official GeoPAT 2 manual](https://zenodo.org/record/1291123). 
It contains installation instructions, description of the GeoPAT 2 architecture, several workflow paths with examples, and explanations of numerical signatures, dissimilarity measures, and topologies available in GeoPAT 2.

We also encourage users to submit issues and enhancement requests so we may continue to improve our software. 
Furthermore, if you have any question related to GeoPAT 2 please email me at nowosad.jakub@gmail.com.

---
layout: false
class: inverse, middle, center

```{r, include=FALSE, eval=FALSE}
devtools::install_github("ropenscilabs/icon")
```

## Thank you

.pull-left[
## Me:

Twitter: `r icon::ii_social_twitter()` jakub_nowosad

Email: nowosad.jakub@gmail.com
]

.pull-right[
## Resources:

https://nowosad.github.io

http://sil.uc.edu
]

.footnote[
**Slides:** https://github.com/Nowosad/geostat18
]
